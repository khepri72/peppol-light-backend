import { Response } from 'express';
import fs from 'fs';
import path from 'path';
import { base, TABLES } from '../config/airtable';
import { AuthRequest } from '../middlewares/auth';
import { buildSafeFilterFormula } from '../utils/airtableHelpers';
import { extractPdfData } from '../utils/peppolAnalyzer/extractPdf';
import { extractExcelData } from '../utils/peppolAnalyzer/extractExcel';
import { validatePeppolRules } from '../utils/peppolAnalyzer/validate';
import { calculateConformityScore } from '../utils/peppolAnalyzer/score';
import { generatePeppolUBL } from '../utils/peppolAnalyzer/generateUbl';
import { validateInvoiceForPeppol } from '../utils/peppolAnalyzer/validateInvoiceCompleteness';

/**
 * Register an uploaded invoice in Airtable
 * POST /api/invoices
 */
export const registerUploadedInvoice = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;
    const { fileName, fileUrl, status, conformityScore, errorsList, errorsData, xmlFilename, ublFileUrl } = req.body;

    // Validate required fields
    if (!fileName || !fileUrl) {
      return res.status(400).json({ error: 'fileName and fileUrl are required' });
    }

    // Validate status
    const validStatuses = ['uploaded', 'checked', 'converted', 'sent'];
    if (status && !validStatuses.includes(status)) {
      return res.status(400).json({ 
        error: `Invalid status "${status}". Must be one of: uploaded, checked, converted, sent` 
      });
    }

    // Note: La vÃ©rification et l'incrÃ©mentation du quota sont gÃ©rÃ©es par le middleware checkQuota
    // sur la route /api/invoices/analyze. Cette fonction ne fait que crÃ©er l'enregistrement.

    // Create invoice record in Airtable
    // Try to save with all fields, fallback gracefully if some fields don't exist
    let records;
    try {
      records = await base(TABLES.INVOICES).create([
        {
          fields: {
            'User': [userId], // Link to Users table
            'File Name': fileName,
            'File URL': fileUrl,
            'Status': status || 'uploaded',
            'Conformity Score': conformityScore || 0,
            'Errors List': errorsList || '',
            'Errors Data': errorsData || '', // JSON string for i18n translation
            'XML Filename': xmlFilename || '', // Real XML filename for UBL download
            'UBL File URL': ublFileUrl || '', // Direct URL for UBL download
            // Note: 'Created At' is auto-generated by Airtable if it's a Created Time field
          },
        },
      ]);
    } catch (error: any) {
      // If new fields don't exist in Airtable, retry without them
      if (error.statusCode === 422 || error.message?.includes('INVALID_FIELD_NAME')) {
        console.log('âš ï¸  Some Airtable fields not found, saving in compatibility mode');
        records = await base(TABLES.INVOICES).create([
          {
            fields: {
              'User': [userId],
              'File Name': fileName,
              'File URL': fileUrl,
              'Status': status || 'uploaded',
              'Conformity Score': conformityScore || 0,
              'Errors List': errorsList || '',
              // New fields omitted - may not exist yet
            },
          },
        ]);
      } else {
        // Re-throw if it's a different error
        throw error;
      }
    }

    const invoice = records[0];

    // Note: L'incrÃ©mentation du quota est gÃ©rÃ©e par le middleware checkQuota
    // sur la route /api/invoices/analyze - pas besoin de le faire ici

    res.status(201).json({
      id: invoice.id,
      fileName: invoice.fields['File Name'],
      fileUrl: invoice.fields['File URL'],
      status: invoice.fields['Status'],
      conformityScore: invoice.fields['Conformity Score'],
      errorsList: invoice.fields['Errors List'],
      errorsData: invoice.fields['Errors Data'],
      xmlFilename: invoice.fields['XML Filename'],
      ublFileUrl: invoice.fields['UBL File URL'],
      createdAt: invoice.fields['Created At'],
    });
  } catch (error: any) {
    console.error('Register invoice error:', error);
    res.status(500).json({ error: 'Failed to register invoice' });
  }
};

/**
 * Get all invoices for the authenticated user
 * GET /api/invoices
 */
export const getInvoices = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;

    // Get all invoices and filter in code
    // Note: Airtable's linked record fields return arrays, so we can't use simple equality
    const records = await base(TABLES.INVOICES)
      .select({
        sort: [{ field: 'Created At', direction: 'desc' }],
      })
      .all();
    
    // Filter records where the User array includes the current userId
    const userRecords = records.filter(record => {
      const userIds = record.fields['User'] as string[] | undefined;
      return userIds && userIds.includes(userId);
    });

    const invoices = userRecords.map((record) => ({
      id: record.id,
      fileName: record.fields['File Name'],
      fileUrl: record.fields['File URL'],
      status: record.fields['Status'],
      conformityScore: record.fields['Conformity Score'],
      errorsList: record.fields['Errors List'],
      errorsData: record.fields['Errors Data'],
      xmlFilename: record.fields['XML Filename'],
      ublFileUrl: record.fields['UBL File URL'],
      createdAt: record.fields['Created At'],
    }));

    res.json({ invoices, count: invoices.length });
  } catch (error) {
    console.error('Get invoices error:', error);
    res.status(500).json({ error: 'Failed to fetch invoices' });
  }
};

/**
 * Analyze an uploaded invoice with Peppol engine
 * POST /api/invoices/analyze
 * 
 * FLUX:
 * 1. Extraction donnÃ©es PDF/Excel â†’ invoiceData
 * 2. Validation Peppol â†’ validationResults
 * 3. Calcul score â†’ score
 * 4. Validation champs critiques â†’ completenessErrors
 * 5. CrÃ©ation enregistrement Airtable (TOUJOURS, mÃªme si incomplet)
 * 6. Si incomplet â†’ HTTP 422 avec status="IncomplÃ¨te"
 * 7. Si complet â†’ GÃ©nÃ©ration XML + HTTP 200 avec status="AnalysÃ©e"
 */
export const analyzeInvoice = async (req: AuthRequest, res: Response) => {
  console.log('ðŸ”µ [ANALYZE] Fonction analyzeInvoice appelÃ©e');
  console.log('ðŸ”µ [ANALYZE] req.file:', req.file ? req.file.filename : 'UNDEFINED');
  console.log('ðŸ”µ [ANALYZE] req.body:', JSON.stringify(req.body));
  
  try {
    const userId = req.userId!;
    
    if (!req.file) {
      console.error('ðŸ”´ [ANALYZE] Pas de fichier uploadÃ©!');
      return res.status(400).json({ error: 'No file uploaded' });
    }

    const filePath = req.file.path;
    const fileType = req.file.mimetype;
    const originalFilename = req.file.originalname;
    const storedFilename = req.file.filename;
    const fileUrl = `/api/uploads/${storedFilename}`;
    
    console.log('ðŸ”µ [ANALYZE] filePath:', filePath);
    console.log('ðŸ”µ [ANALYZE] fileType:', fileType);
    
    // ========================================
    // Ã‰TAPE 1: Extraction selon type de fichier
    // ========================================
    let invoiceData;
    console.log('ðŸ”µ [ANALYZE] Ã‰tape 1: Extraction...');
    if (fileType === 'application/pdf') {
      invoiceData = await extractPdfData(filePath);
    } else if (fileType.includes('spreadsheet') || fileType.includes('excel')) {
      invoiceData = extractExcelData(filePath);
    } else {
      console.error('ðŸ”´ [ANALYZE] Type de fichier non supportÃ©:', fileType);
      return res.status(400).json({ error: 'Type de fichier non supportÃ©. Utilisez PDF ou Excel.' });
    }
    console.log('ðŸ”µ [ANALYZE] DonnÃ©es extraites:', JSON.stringify(invoiceData).substring(0, 200));
    
    // ========================================
    // Ã‰TAPE 2: Validation Peppol (rÃ¨gles)
    // ========================================
    console.log('ðŸ”µ [ANALYZE] Ã‰tape 2: Validation Peppol...');
    const validationResults = validatePeppolRules(invoiceData);
    const validationErrors = validationResults.filter(v => v.severity === 'error');
    const validationWarnings = validationResults.filter(v => v.severity === 'warning');
    console.log('ðŸ”µ [ANALYZE] RÃ©sultats validation:', validationResults.length, 'rÃ¨gles');
    
    // ========================================
    // Ã‰TAPE 3: Calcul du score
    // ========================================
    console.log('ðŸ”µ [ANALYZE] Ã‰tape 3: Calcul du score...');
    const score = calculateConformityScore(validationResults);
    const scoreValue = typeof score === 'number' ? score : parseInt(String(score), 10) || 0;
    console.log('ðŸ”µ [ANALYZE] Score:', scoreValue);
    
    // ========================================
    // Ã‰TAPE 4: Validation des champs critiques
    // ========================================
    console.log('ðŸ”µ [ANALYZE] Ã‰tape 4: Validation des champs critiques...');
    const completenessErrors = validateInvoiceForPeppol(invoiceData);
    const isComplete = completenessErrors.length === 0;
    console.log('ðŸ”µ [ANALYZE] Facture complÃ¨te:', isComplete);
    if (!isComplete) {
      console.log('ðŸ”´ [ANALYZE] Champs manquants:', completenessErrors.map(e => e.field).join(', '));
    }
    
    // ========================================
    // Ã‰TAPE 5: CrÃ©ation enregistrement Airtable (TOUJOURS)
    // ========================================
    console.log('ðŸ”µ [ANALYZE] Ã‰tape 5: CrÃ©ation enregistrement Airtable...');
    
    // PrÃ©parer les donnÃ©es pour Airtable
    const status = isComplete ? 'AnalysÃ©e' : 'IncomplÃ¨te';
    
    // Format des erreurs pour stockage
    const allErrors = isComplete 
      ? validationErrors 
      : [...completenessErrors.map(e => ({ field: e.field, code: 'MISSING_FIELD', severity: 'error' as const, message: e.message })), ...validationErrors];
    
    const errorsList = [
      ...allErrors.map(e => `ERREUR: ${e.message}`),
      ...validationWarnings.map(w => `AVERTISSEMENT: ${w.message}`)
    ].join('\n');
    
    const errorsData = JSON.stringify({ 
      errors: allErrors, 
      warnings: validationWarnings,
      completenessErrors: isComplete ? [] : completenessErrors
    });
    
    let invoiceRecord;
    try {
      const records = await base(TABLES.INVOICES).create([
        {
          fields: {
            'User': [userId],
            'File Name': originalFilename,
            'File URL': fileUrl,
            'Status': status,
            'Conformity Score': scoreValue,
            'Errors List': errorsList,
            'Errors Data': errorsData,
            'XML Filename': '',
            'UBL File URL': '',
          },
        },
      ]);
      invoiceRecord = records[0];
      console.log(`âœ… [ANALYZE] Invoice crÃ©Ã©e avec ID: ${invoiceRecord.id}, Status: ${status}`);
    } catch (createError: any) {
      // Fallback si certains champs n'existent pas
      if (createError.statusCode === 422 || createError.message?.includes('INVALID_FIELD_NAME')) {
        console.log('âš ï¸ [ANALYZE] Retry crÃ©ation sans certains champs...');
        const records = await base(TABLES.INVOICES).create([
          {
            fields: {
              'User': [userId],
              'File Name': originalFilename,
              'File URL': fileUrl,
              'Status': status,
              'Conformity Score': scoreValue,
              'Errors List': errorsList,
            },
          },
        ]);
        invoiceRecord = records[0];
        console.log(`âœ… [ANALYZE] Invoice crÃ©Ã©e (mode compatibilitÃ©) avec ID: ${invoiceRecord.id}`);
      } else {
        throw createError;
      }
    }
    
    const invoiceId = invoiceRecord.id;
    
    // ========================================
    // Ã‰TAPE 6: Si INCOMPLET â†’ Retourner 422
    // ========================================
    if (!isComplete) {
      console.log('ðŸ”´ [ANALYZE] Facture incomplÃ¨te, retour HTTP 422');
      return res.status(422).json({
        success: false,
        code: 'INVOICE_INCOMPLETE',
        message: 'La facture est incomplÃ¨te pour gÃ©nÃ©rer un XML Peppol conforme.',
        errors: completenessErrors,
        score: scoreValue,
        validationResults: validationErrors,
        warnings: validationWarnings,
        extractedData: invoiceData,
        invoiceId: invoiceId
      });
    }
    
    // ========================================
    // Ã‰TAPE 7: Si COMPLET â†’ GÃ©nÃ©ration UBL/XML
    // ========================================
    console.log('âœ… [ANALYZE] Facture complÃ¨te, gÃ©nÃ©ration UBL...');
    let ublXml = '';
    let xmlFilename = '';
    
    try {
      ublXml = generatePeppolUBL(invoiceData);
      console.log('ðŸ”µ [ANALYZE] XML gÃ©nÃ©rÃ©, longueur:', ublXml.length, 'caractÃ¨res');
      
      // Calculer le nom XML
      const extname = path.extname(storedFilename);
      const baseFilename = storedFilename.replace(extname, '');
      xmlFilename = `${baseFilename}.xml`;
      
      // Mettre Ã  jour l'enregistrement avec le XML
      await base(TABLES.INVOICES).update(invoiceId, {
        'UBL Content': ublXml,
        'XML Filename': xmlFilename,
        'UBL File URL': `/api/invoices/download-ubl/${invoiceId}`,
      });
      console.log(`âœ… [ANALYZE] UBL Content sauvegardÃ© pour invoice ${invoiceId}`);
      
    } catch (ublError: any) {
      console.error('ðŸ”´ [ANALYZE] ERREUR gÃ©nÃ©ration/sauvegarde UBL:', ublError.message);
      // On continue mÃªme si le XML Ã©choue - l'invoice est crÃ©Ã©e
    }
    
    // Mettre Ã  jour les champs optionnels
    try {
      await base(TABLES.INVOICES).update(invoiceId, {
        'Invoice Number': invoiceData.invoiceNumber || '',
        'Invoice Date': invoiceData.issueDate || '',
        'Total Amount': invoiceData.totals?.grossAmount || 0,
      });
    } catch (optionalError: any) {
      console.log('âš ï¸ [ANALYZE] Champs optionnels non mis Ã  jour');
    }
    
    // ========================================
    // Ã‰TAPE 8: Retourner HTTP 200 (succÃ¨s)
    // ========================================
    console.log('âœ… [ANALYZE] Analyse rÃ©ussie, retour HTTP 200');
    res.json({
      success: true,
      message: 'Analyse rÃ©ussie',
      score: scoreValue,
      errors: validationErrors,
      warnings: validationWarnings,
      xmlFilename: xmlFilename || null,
      ublFileUrl: `/api/invoices/download-ubl/${invoiceId}`,
      extractedData: invoiceData,
      invoiceId: invoiceId
    });
    
  } catch (error: any) {
    console.error('ðŸ”´ [ANALYZE] ERREUR GLOBALE:', error);
    console.error('ðŸ”´ [ANALYZE] Stack:', error?.stack);
    res.status(500).json({ 
      success: false, 
      error: 'Erreur lors de l\'analyse de la facture' 
    });
  }
};

/**
 * Delete an invoice
 * DELETE /api/invoices/:id
 */
export const deleteInvoice = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;
    const { id } = req.params;

    // First, fetch the record to verify ownership
    const record = await base(TABLES.INVOICES).find(id);

    // Check if the user owns this invoice
    // The 'User' field is an array of user IDs (linked record)
    const userIds = record.fields['User'] as string[];
    if (!userIds || !userIds.includes(userId)) {
      return res.status(403).json({ error: 'Access denied to this invoice' });
    }

    // Delete the invoice
    await base(TABLES.INVOICES).destroy([id]);

    res.json({ message: 'Invoice deleted successfully' });
  } catch (error: any) {
    console.error('Delete invoice error:', error);
    
    if (error.statusCode === 404 || error.message?.includes('NOT_FOUND')) {
      return res.status(404).json({ error: 'Invoice not found' });
    }
    
    res.status(500).json({ error: 'Failed to delete invoice' });
  }
};
