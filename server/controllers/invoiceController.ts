import { Response } from 'express';
import fs from 'fs';
import { base, TABLES } from '../config/airtable';
import { AuthRequest } from '../middlewares/auth';
import { buildSafeFilterFormula } from '../utils/airtableHelpers';
import { extractPdfData } from '../utils/peppolAnalyzer/extractPdf';
import { extractExcelData } from '../utils/peppolAnalyzer/extractExcel';
import { validatePeppolRules } from '../utils/peppolAnalyzer/validate';
import { calculateConformityScore } from '../utils/peppolAnalyzer/score';
import { generatePeppolUBL } from '../utils/peppolAnalyzer/generateUbl';

/**
 * Register an uploaded invoice in Airtable
 * POST /api/invoices
 */
export const registerUploadedInvoice = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;
    const { fileName, fileUrl, status, conformityScore, errorsList } = req.body;

    // Validate required fields
    if (!fileName || !fileUrl) {
      return res.status(400).json({ error: 'fileName and fileUrl are required' });
    }

    // Validate status
    const validStatuses = ['uploaded', 'checked', 'converted', 'sent'];
    if (status && !validStatuses.includes(status)) {
      return res.status(400).json({ 
        error: `Invalid status "${status}". Must be one of: uploaded, checked, converted, sent` 
      });
    }

    // Check user quota before creating invoice
    const user = await base(TABLES.USERS).find(userId);
    const quotaLimit = user.fields.quotaLimit !== undefined ? Number(user.fields.quotaLimit) : 1;
    const quotaUsed = user.fields.quotaUsed !== undefined ? Number(user.fields.quotaUsed) : 0;
    const isUnlimited = quotaLimit === -1;

    // Block if quota exceeded
    if (!isUnlimited && quotaUsed >= quotaLimit) {
      return res.status(403).json({ 
        error: `Quota limit reached. You have used ${quotaUsed}/${quotaLimit} uploads this month. Upgrade your plan to continue.` 
      });
    }

    // Create invoice record in Airtable
    const records = await base(TABLES.INVOICES).create([
      {
        fields: {
          'User': [userId], // Link to Users table
          'File Name': fileName,
          'File URL': fileUrl,
          'Status': status || 'uploaded',
          'Conformity Score': conformityScore || 0,
          'Errors List': errorsList || '',
          // Note: 'Created At' is auto-generated by Airtable if it's a Created Time field
        },
      },
    ]);

    const invoice = records[0];

    // Increment quotaUsed after successful upload (only if not unlimited)
    if (!isUnlimited) {
      await base(TABLES.USERS).update(userId, {
        quotaUsed: quotaUsed + 1
      });
    }

    res.status(201).json({
      id: invoice.id,
      fileName: invoice.fields['File Name'],
      fileUrl: invoice.fields['File URL'],
      status: invoice.fields['Status'],
      conformityScore: invoice.fields['Conformity Score'],
      errorsList: invoice.fields['Errors List'],
      createdAt: invoice.fields['Created At'],
    });
  } catch (error: any) {
    console.error('Register invoice error:', error);
    res.status(500).json({ error: 'Failed to register invoice' });
  }
};

/**
 * Get all invoices for the authenticated user
 * GET /api/invoices
 */
export const getInvoices = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;

    // Get all invoices and filter in code
    // Note: Airtable's linked record fields return arrays, so we can't use simple equality
    const records = await base(TABLES.INVOICES)
      .select({
        sort: [{ field: 'Created At', direction: 'desc' }],
      })
      .all();
    
    // Filter records where the User array includes the current userId
    const userRecords = records.filter(record => {
      const userIds = record.fields['User'] as string[] | undefined;
      return userIds && userIds.includes(userId);
    });

    const invoices = userRecords.map((record) => ({
      id: record.id,
      fileName: record.fields['File Name'],
      fileUrl: record.fields['File URL'],
      status: record.fields['Status'],
      conformityScore: record.fields['Conformity Score'],
      errorsList: record.fields['Errors List'],
      createdAt: record.fields['Created At'],
    }));

    res.json({ invoices, count: invoices.length });
  } catch (error) {
    console.error('Get invoices error:', error);
    res.status(500).json({ error: 'Failed to fetch invoices' });
  }
};

/**
 * Analyze an uploaded invoice with Peppol engine
 * POST /api/invoices/analyze
 */
export const analyzeInvoice = async (req: AuthRequest, res: Response) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    const filePath = req.file.path;
    const fileType = req.file.mimetype;
    
    // 1. Extraction selon type
    let invoiceData;
    if (fileType === 'application/pdf') {
      invoiceData = await extractPdfData(filePath);
    } else if (fileType.includes('spreadsheet') || fileType.includes('excel')) {
      invoiceData = extractExcelData(filePath);
    } else {
      return res.status(400).json({ error: 'Type de fichier non supporté. Utilisez PDF ou Excel.' });
    }
    
    // 2. Validation
    const validationResults = validatePeppolRules(invoiceData);
    
    // 3. Score
    const score = calculateConformityScore(validationResults);
    
    // 4. Génération UBL
    let ublXml = '';
    let xmlPath = '';
    try {
      ublXml = generatePeppolUBL(invoiceData);
      
      // Sauvegarder XML
      xmlPath = `${filePath}.xml`;
      fs.writeFileSync(xmlPath, ublXml);
    } catch (ublError) {
      console.error('Erreur génération UBL:', ublError);
    }
    
    // 5. Réponse
    res.json({
      success: true,
      score,
      errors: validationResults.filter(v => v.severity === 'error'),
      warnings: validationResults.filter(v => v.severity === 'warning'),
      xmlPath: ublXml ? `${req.file.filename}.xml` : null,
      extractedData: invoiceData
    });
    
  } catch (error) {
    console.error('Erreur analyse:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Erreur lors de l\'analyse de la facture' 
    });
  }
};

/**
 * Delete an invoice
 * DELETE /api/invoices/:id
 */
export const deleteInvoice = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;
    const { id } = req.params;

    // First, fetch the record to verify ownership
    const record = await base(TABLES.INVOICES).find(id);

    // Check if the user owns this invoice
    // The 'User' field is an array of user IDs (linked record)
    const userIds = record.fields['User'] as string[];
    if (!userIds || !userIds.includes(userId)) {
      return res.status(403).json({ error: 'Access denied to this invoice' });
    }

    // Delete the invoice
    await base(TABLES.INVOICES).destroy([id]);

    res.json({ message: 'Invoice deleted successfully' });
  } catch (error: any) {
    console.error('Delete invoice error:', error);
    
    if (error.statusCode === 404 || error.message?.includes('NOT_FOUND')) {
      return res.status(404).json({ error: 'Invoice not found' });
    }
    
    res.status(500).json({ error: 'Failed to delete invoice' });
  }
};
