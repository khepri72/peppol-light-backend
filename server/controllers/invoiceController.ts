import { Response } from 'express';
import fs from 'fs';
import path from 'path';
import { base, TABLES } from '../config/airtable';
import { AuthRequest } from '../middlewares/auth';
import { buildSafeFilterFormula } from '../utils/airtableHelpers';
import { extractPdfData } from '../utils/peppolAnalyzer/extractPdf';
import { extractExcelData } from '../utils/peppolAnalyzer/extractExcel';
import { validatePeppolRules } from '../utils/peppolAnalyzer/validate';
import { calculateConformityScore } from '../utils/peppolAnalyzer/score';
import { generatePeppolUBL } from '../utils/peppolAnalyzer/generateUbl';

/**
 * Register an uploaded invoice in Airtable
 * POST /api/invoices
 */
export const registerUploadedInvoice = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;
    const { fileName, fileUrl, status, conformityScore, errorsList, errorsData, xmlFilename, ublFileUrl } = req.body;

    // Validate required fields
    if (!fileName || !fileUrl) {
      return res.status(400).json({ error: 'fileName and fileUrl are required' });
    }

    // Validate status
    const validStatuses = ['uploaded', 'checked', 'converted', 'sent'];
    if (status && !validStatuses.includes(status)) {
      return res.status(400).json({ 
        error: `Invalid status "${status}". Must be one of: uploaded, checked, converted, sent` 
      });
    }

    // Check user quota before creating invoice
    const user = await base(TABLES.USERS).find(userId);
    const quotaLimit = user.fields.quotaLimit !== undefined ? Number(user.fields.quotaLimit) : 1;
    const quotaUsed = user.fields.quotaUsed !== undefined ? Number(user.fields.quotaUsed) : 0;
    const isUnlimited = quotaLimit === -1;

    // Block if quota exceeded
    if (!isUnlimited && quotaUsed >= quotaLimit) {
      return res.status(403).json({ 
        error: `Quota limit reached. You have used ${quotaUsed}/${quotaLimit} uploads this month. Upgrade your plan to continue.` 
      });
    }

    // Create invoice record in Airtable
    // Try to save with all fields, fallback gracefully if some fields don't exist
    let records;
    try {
      records = await base(TABLES.INVOICES).create([
        {
          fields: {
            'User': [userId], // Link to Users table
            'File Name': fileName,
            'File URL': fileUrl,
            'Status': status || 'uploaded',
            'Conformity Score': conformityScore || 0,
            'Errors List': errorsList || '',
            'Errors Data': errorsData || '', // JSON string for i18n translation
            'XML Filename': xmlFilename || '', // Real XML filename for UBL download
            'UBL File URL': ublFileUrl || '', // Direct URL for UBL download
            // Note: 'Created At' is auto-generated by Airtable if it's a Created Time field
          },
        },
      ]);
    } catch (error: any) {
      // If new fields don't exist in Airtable, retry without them
      if (error.statusCode === 422 || error.message?.includes('INVALID_FIELD_NAME')) {
        console.log('âš ï¸  Some Airtable fields not found, saving in compatibility mode');
        records = await base(TABLES.INVOICES).create([
          {
            fields: {
              'User': [userId],
              'File Name': fileName,
              'File URL': fileUrl,
              'Status': status || 'uploaded',
              'Conformity Score': conformityScore || 0,
              'Errors List': errorsList || '',
              // New fields omitted - may not exist yet
            },
          },
        ]);
      } else {
        // Re-throw if it's a different error
        throw error;
      }
    }

    const invoice = records[0];

    // Increment quotaUsed after successful upload (only if not unlimited)
    if (!isUnlimited) {
      await base(TABLES.USERS).update(userId, {
        quotaUsed: quotaUsed + 1
      });
    }

    res.status(201).json({
      id: invoice.id,
      fileName: invoice.fields['File Name'],
      fileUrl: invoice.fields['File URL'],
      status: invoice.fields['Status'],
      conformityScore: invoice.fields['Conformity Score'],
      errorsList: invoice.fields['Errors List'],
      errorsData: invoice.fields['Errors Data'],
      xmlFilename: invoice.fields['XML Filename'],
      ublFileUrl: invoice.fields['UBL File URL'],
      createdAt: invoice.fields['Created At'],
    });
  } catch (error: any) {
    console.error('Register invoice error:', error);
    res.status(500).json({ error: 'Failed to register invoice' });
  }
};

/**
 * Get all invoices for the authenticated user
 * GET /api/invoices
 */
export const getInvoices = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;

    // Get all invoices and filter in code
    // Note: Airtable's linked record fields return arrays, so we can't use simple equality
    const records = await base(TABLES.INVOICES)
      .select({
        sort: [{ field: 'Created At', direction: 'desc' }],
      })
      .all();
    
    // Filter records where the User array includes the current userId
    const userRecords = records.filter(record => {
      const userIds = record.fields['User'] as string[] | undefined;
      return userIds && userIds.includes(userId);
    });

    const invoices = userRecords.map((record) => ({
      id: record.id,
      fileName: record.fields['File Name'],
      fileUrl: record.fields['File URL'],
      status: record.fields['Status'],
      conformityScore: record.fields['Conformity Score'],
      errorsList: record.fields['Errors List'],
      errorsData: record.fields['Errors Data'],
      xmlFilename: record.fields['XML Filename'],
      ublFileUrl: record.fields['UBL File URL'],
      createdAt: record.fields['Created At'],
    }));

    res.json({ invoices, count: invoices.length });
  } catch (error) {
    console.error('Get invoices error:', error);
    res.status(500).json({ error: 'Failed to fetch invoices' });
  }
};

/**
 * Analyze an uploaded invoice with Peppol engine
 * POST /api/invoices/analyze
 */
export const analyzeInvoice = async (req: AuthRequest, res: Response) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    const filePath = req.file.path;
    const fileType = req.file.mimetype;
    
    // 1. Extraction selon type
    let invoiceData;
    if (fileType === 'application/pdf') {
      invoiceData = await extractPdfData(filePath);
    } else if (fileType.includes('spreadsheet') || fileType.includes('excel')) {
      invoiceData = extractExcelData(filePath);
    } else {
      return res.status(400).json({ error: 'Type de fichier non supportÃ©. Utilisez PDF ou Excel.' });
    }
    
    // 2. Validation
    const validationResults = validatePeppolRules(invoiceData);
    
    // 3. Score
    const score = calculateConformityScore(validationResults);
    
    // 4. GÃ©nÃ©ration UBL
    let ublXml = '';
    let xmlPath = '';
    let xmlFilename = '';
    try {
      ublXml = generatePeppolUBL(invoiceData);
      
      // Calculer le nom XML SANS double extension (.pdf.xml â†’ .xml)
      // req.file.filename = "invoice-123456789.pdf" â†’ baseFilename = "invoice-123456789"
      const originalFilename = req.file.filename;
      const extname = path.extname(originalFilename); // ".pdf" ou ".xlsx"
      const baseFilename = originalFilename.replace(extname, ''); // "invoice-123456789"
      xmlFilename = `${baseFilename}.xml`; // "invoice-123456789.xml"
      
      // Utiliser le mÃªme dossier uploads que Multer (process.cwd()/server/uploads)
      const uploadsDir = path.join(process.cwd(), 'server', 'uploads');
      if (!fs.existsSync(uploadsDir)) {
        fs.mkdirSync(uploadsDir, { recursive: true });
        console.log('ðŸ“ Created uploads directory at', uploadsDir);
      }
      
      xmlPath = path.join(uploadsDir, xmlFilename);
      fs.writeFileSync(xmlPath, ublXml);
      console.log(`âœ… UBL XML gÃ©nÃ©rÃ©: ${xmlFilename} â†’ ${xmlPath}`);
      
      // Mise Ã  jour Airtable avec les mÃ©tadonnÃ©es UBL
      const { invoiceId } = req.body;
      if (invoiceId) {
        try {
          await base(TABLES.INVOICES).update(invoiceId, {
            'XML Filename': xmlFilename,
            'UBL File URL': `/api/invoices/download-ubl/${xmlFilename}`,
            'Invoice Number': invoiceData.invoiceNumber || '',
            'Invoice Date': invoiceData.issueDate || '',
            'Total Amount': invoiceData.totals?.grossAmount || 0,
            'Invoice Data': JSON.stringify(invoiceData, null, 2),
            'Status': 'UBL Generated',
          });
          console.log(`âœ… Airtable mis Ã  jour pour invoice ${invoiceId}`);
        } catch (airtableError) {
          console.error('âš ï¸ Erreur mise Ã  jour Airtable:', airtableError);
        }
      }
    } catch (ublError) {
      console.error('Erreur gÃ©nÃ©ration UBL:', ublError);
    }
    
    // 5. RÃ©ponse avec le vrai nom du fichier XML
    res.json({
      success: true,
      score,
      errors: validationResults.filter(v => v.severity === 'error'),
      warnings: validationResults.filter(v => v.severity === 'warning'),
      xmlFilename: xmlFilename || null,
      ublFileUrl: xmlFilename ? `/api/invoices/download-ubl/${xmlFilename}` : null,
      extractedData: invoiceData
    });
    
  } catch (error) {
    console.error('Erreur analyse:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Erreur lors de l\'analyse de la facture' 
    });
  }
};

/**
 * Delete an invoice
 * DELETE /api/invoices/:id
 */
export const deleteInvoice = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;
    const { id } = req.params;

    // First, fetch the record to verify ownership
    const record = await base(TABLES.INVOICES).find(id);

    // Check if the user owns this invoice
    // The 'User' field is an array of user IDs (linked record)
    const userIds = record.fields['User'] as string[];
    if (!userIds || !userIds.includes(userId)) {
      return res.status(403).json({ error: 'Access denied to this invoice' });
    }

    // Delete the invoice
    await base(TABLES.INVOICES).destroy([id]);

    res.json({ message: 'Invoice deleted successfully' });
  } catch (error: any) {
    console.error('Delete invoice error:', error);
    
    if (error.statusCode === 404 || error.message?.includes('NOT_FOUND')) {
      return res.status(404).json({ error: 'Invoice not found' });
    }
    
    res.status(500).json({ error: 'Failed to delete invoice' });
  }
};
