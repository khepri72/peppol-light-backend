import { Response } from 'express';
import fs from 'fs';
import { base, TABLES } from '../config/airtable';
import { AuthRequest } from '../middlewares/auth';
import { buildSafeFilterFormula } from '../utils/airtableHelpers';
import { extractPdfData } from '../utils/peppolAnalyzer/extractPdf';
import { extractExcelData } from '../utils/peppolAnalyzer/extractExcel';
import { validatePeppolRules } from '../utils/peppolAnalyzer/validate';
import { calculateConformityScore } from '../utils/peppolAnalyzer/score';
import { generatePeppolUBL } from '../utils/peppolAnalyzer/generateUbl';

/**
 * Register an uploaded invoice in Airtable
 * POST /api/invoices
 */
export const registerUploadedInvoice = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;
    const { fileName, fileUrl, status, conformityScore, errorsList, errorsData, xmlFilename, ublFileUrl } = req.body;

    // Validate required fields
    if (!fileName || !fileUrl) {
      return res.status(400).json({ error: 'fileName and fileUrl are required' });
    }

    // Validate status
    const validStatuses = ['uploaded', 'checked', 'converted', 'sent'];
    if (status && !validStatuses.includes(status)) {
      return res.status(400).json({ 
        error: `Invalid status "${status}". Must be one of: uploaded, checked, converted, sent` 
      });
    }

    // Check user quota before creating invoice
    const user = await base(TABLES.USERS).find(userId);
    const quotaLimit = user.fields.quotaLimit !== undefined ? Number(user.fields.quotaLimit) : 1;
    const quotaUsed = user.fields.quotaUsed !== undefined ? Number(user.fields.quotaUsed) : 0;
    const isUnlimited = quotaLimit === -1;

    // Block if quota exceeded
    if (!isUnlimited && quotaUsed >= quotaLimit) {
      return res.status(403).json({ 
        error: `Quota limit reached. You have used ${quotaUsed}/${quotaLimit} uploads this month. Upgrade your plan to continue.` 
      });
    }

    // Create invoice record in Airtable
    // Try to save with all fields, fallback gracefully if some fields don't exist
    let records;
    try {
      records = await base(TABLES.INVOICES).create([
        {
          fields: {
            'User': [userId], // Link to Users table
            'File Name': fileName,
            'File URL': fileUrl,
            'Status': status || 'uploaded',
            'Conformity Score': conformityScore || 0,
            'Errors List': errorsList || '',
            'Errors Data': errorsData || '', // JSON string for i18n translation
            'XML Filename': xmlFilename || '', // Real XML filename for UBL download
            'UBL File URL': ublFileUrl || '', // Direct URL for UBL download
            // Note: 'Created At' is auto-generated by Airtable if it's a Created Time field
          },
        },
      ]);
    } catch (error: any) {
      // If new fields don't exist in Airtable, retry without them
      if (error.statusCode === 422 || error.message?.includes('INVALID_FIELD_NAME')) {
        console.log('⚠️  Some Airtable fields not found, saving in compatibility mode');
        records = await base(TABLES.INVOICES).create([
          {
            fields: {
              'User': [userId],
              'File Name': fileName,
              'File URL': fileUrl,
              'Status': status || 'uploaded',
              'Conformity Score': conformityScore || 0,
              'Errors List': errorsList || '',
              // New fields omitted - may not exist yet
            },
          },
        ]);
      } else {
        // Re-throw if it's a different error
        throw error;
      }
    }

    const invoice = records[0];

    // Increment quotaUsed after successful upload (only if not unlimited)
    if (!isUnlimited) {
      await base(TABLES.USERS).update(userId, {
        quotaUsed: quotaUsed + 1
      });
    }

    res.status(201).json({
      id: invoice.id,
      fileName: invoice.fields['File Name'],
      fileUrl: invoice.fields['File URL'],
      status: invoice.fields['Status'],
      conformityScore: invoice.fields['Conformity Score'],
      errorsList: invoice.fields['Errors List'],
      errorsData: invoice.fields['Errors Data'],
      xmlFilename: invoice.fields['XML Filename'],
      ublFileUrl: invoice.fields['UBL File URL'],
      createdAt: invoice.fields['Created At'],
    });
  } catch (error: any) {
    console.error('Register invoice error:', error);
    res.status(500).json({ error: 'Failed to register invoice' });
  }
};

/**
 * Get all invoices for the authenticated user
 * GET /api/invoices
 */
export const getInvoices = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;

    // Get all invoices and filter in code
    // Note: Airtable's linked record fields return arrays, so we can't use simple equality
    const records = await base(TABLES.INVOICES)
      .select({
        sort: [{ field: 'Created At', direction: 'desc' }],
      })
      .all();
    
    // Filter records where the User array includes the current userId
    const userRecords = records.filter(record => {
      const userIds = record.fields['User'] as string[] | undefined;
      return userIds && userIds.includes(userId);
    });

    const invoices = userRecords.map((record) => ({
      id: record.id,
      fileName: record.fields['File Name'],
      fileUrl: record.fields['File URL'],
      status: record.fields['Status'],
      conformityScore: record.fields['Conformity Score'],
      errorsList: record.fields['Errors List'],
      errorsData: record.fields['Errors Data'],
      xmlFilename: record.fields['XML Filename'],
      ublFileUrl: record.fields['UBL File URL'],
      createdAt: record.fields['Created At'],
    }));

    res.json({ invoices, count: invoices.length });
  } catch (error) {
    console.error('Get invoices error:', error);
    res.status(500).json({ error: 'Failed to fetch invoices' });
  }
};

/**
 * Analyze an uploaded invoice with Peppol engine
 * POST /api/invoices/analyze
 */
export const analyzeInvoice = async (req: AuthRequest, res: Response) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    const filePath = req.file.path;
    const fileType = req.file.mimetype;
    
    // 1. Extraction selon type
    let invoiceData;
    if (fileType === 'application/pdf') {
      invoiceData = await extractPdfData(filePath);
    } else if (fileType.includes('spreadsheet') || fileType.includes('excel')) {
      invoiceData = extractExcelData(filePath);
    } else {
      return res.status(400).json({ error: 'Type de fichier non supporté. Utilisez PDF ou Excel.' });
    }
    
    // 2. Validation
    const validationResults = validatePeppolRules(invoiceData);
    
    // 3. Score
    const score = calculateConformityScore(validationResults);
    
    // 4. Génération UBL
    let ublXml = '';
    let xmlPath = '';
    let xmlFilename = '';
    try {
      ublXml = generatePeppolUBL(invoiceData);
      
      // Sauvegarder XML avec le vrai nom de fichier
      xmlPath = `${filePath}.xml`;
      xmlFilename = `${req.file.filename}.xml`;
      fs.writeFileSync(xmlPath, ublXml);
      console.log(`✅ UBL XML généré: ${xmlFilename}`);
      
    } catch (ublError) {
      console.error('Erreur génération UBL:', ublError);
    }
    
    // 5. Préparer les données d'erreurs
    const errors = validationResults.filter(v => v.severity === 'error');
    const warnings = validationResults.filter(v => v.severity === 'warning');
    const errorsList = [
      ...errors.map(e => `ERROR: ${e.message}`),
      ...warnings.map(w => `WARNING: ${w.message}`)
    ].join('\n');
    const errorsData = JSON.stringify({ errors, warnings });
    
    // 6. Sauvegarde COMPLÈTE dans Airtable (score + errors + UBL)
    // Note: Cette mise à jour ne doit PAS bloquer la réponse au frontend
    const invoiceId = req.body.invoiceId;
    if (invoiceId) {
      try {
        // Sanitize invoiceData fields (may be null/undefined if extraction failed)
        const safeInvoiceNumber = invoiceData?.invoiceNumber || '';
        const safeIssueDate = invoiceData?.issueDate || invoiceData?.issueDateISO || '';
        const safeTotalAmount = invoiceData?.totals?.grossAmount || 0;
        const safeInvoiceDataJson = invoiceData ? JSON.stringify(invoiceData, null, 2) : '{}';
        
        await base(TABLES.INVOICES).update(invoiceId, {
          'Status': score >= 80 ? 'checked' : 'pending',
          'Conformity Score': score,
          'Errors List': errorsList,
          'Errors Data': errorsData,
          'XML Filename': xmlFilename || '',
          'UBL File URL': xmlFilename ? `/api/invoices/download-ubl/${xmlFilename}` : '',
          'Invoice Number': safeInvoiceNumber,
          'Invoice Date': safeIssueDate,
          'Total Amount': safeTotalAmount,
          'Invoice Data': safeInvoiceDataJson,
        });
        console.log(`✅ Airtable updated: ${invoiceId} | Score: ${score}% | XML: ${xmlFilename}`);
      } catch (airtableError: any) {
        // Log but don't abort - frontend still needs the analysis results
        console.error("❌ Erreur sauvegarde Airtable (non-bloquante):", airtableError.message || airtableError);
      }
    } else {
      console.log("⚠️ Pas d'invoiceId - Airtable non mis à jour");
    }
    
    // 7. Réponse avec toutes les données
    res.json({
      success: true,
      score,
      errors,
      warnings,
      errorsList,
      errorsData,
      xmlFilename: xmlFilename || null,
      ublFileUrl: xmlFilename ? `/api/invoices/download-ubl/${xmlFilename}` : null,
      extractedData: invoiceData
    });
    
  } catch (error) {
    console.error('Erreur analyse:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Erreur lors de l\'analyse de la facture' 
    });
  }
};

/**
 * Update an invoice (partial update)
 * PATCH /api/invoices/:id
 */
export const updateInvoice = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;
    const { id } = req.params;
    const updateData = req.body;

    // First, fetch the record to verify ownership
    const record = await base(TABLES.INVOICES).find(id);

    // Check if the user owns this invoice
    // User field is a linked record array - Airtable returns array of record IDs
    const userLinks = record.fields['User'] as string[] | undefined;
    if (!userLinks || !userLinks.includes(userId)) {
      return res.status(403).json({ error: 'Access denied to this invoice' });
    }

    // Build update fields (only update provided fields)
    const fieldsToUpdate: Record<string, any> = {};
    
    if (updateData.status !== undefined) fieldsToUpdate['Status'] = updateData.status;
    if (updateData.conformityScore !== undefined) fieldsToUpdate['Conformity Score'] = updateData.conformityScore;
    if (updateData.errorsList !== undefined) fieldsToUpdate['Errors List'] = updateData.errorsList;
    if (updateData.errorsData !== undefined) fieldsToUpdate['Errors Data'] = updateData.errorsData;
    if (updateData.xmlFilename !== undefined) fieldsToUpdate['XML Filename'] = updateData.xmlFilename;
    if (updateData.ublFileUrl !== undefined) fieldsToUpdate['UBL File URL'] = updateData.ublFileUrl;

    // Update the invoice
    const updatedRecord = await base(TABLES.INVOICES).update(id, fieldsToUpdate);

    res.json({
      id: updatedRecord.id,
      fileName: updatedRecord.fields['File Name'],
      fileUrl: updatedRecord.fields['File URL'],
      status: updatedRecord.fields['Status'],
      conformityScore: updatedRecord.fields['Conformity Score'],
      errorsList: updatedRecord.fields['Errors List'],
      errorsData: updatedRecord.fields['Errors Data'],
      xmlFilename: updatedRecord.fields['XML Filename'],
      ublFileUrl: updatedRecord.fields['UBL File URL'],
    });
  } catch (error: any) {
    console.error('Update invoice error:', error);
    
    if (error.statusCode === 404 || error.message?.includes('NOT_FOUND')) {
      return res.status(404).json({ error: 'Invoice not found' });
    }
    
    res.status(500).json({ error: 'Failed to update invoice' });
  }
};

/**
 * Delete an invoice
 * DELETE /api/invoices/:id
 */
export const deleteInvoice = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;
    const { id } = req.params;

    // First, fetch the record to verify ownership
    const record = await base(TABLES.INVOICES).find(id);

    // Check if the user owns this invoice
    // The 'User' field is an array of user IDs (linked record)
    const userIds = record.fields['User'] as string[];
    if (!userIds || !userIds.includes(userId)) {
      return res.status(403).json({ error: 'Access denied to this invoice' });
    }

    // Delete the invoice
    await base(TABLES.INVOICES).destroy([id]);

    res.json({ message: 'Invoice deleted successfully' });
  } catch (error: any) {
    console.error('Delete invoice error:', error);
    
    if (error.statusCode === 404 || error.message?.includes('NOT_FOUND')) {
      return res.status(404).json({ error: 'Invoice not found' });
    }
    
    res.status(500).json({ error: 'Failed to delete invoice' });
  }
};
