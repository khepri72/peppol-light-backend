import { Response } from 'express';
import fs from 'fs';
import path from 'path';
import { base, TABLES } from '../config/airtable';
import { AuthRequest } from '../middlewares/auth';
import { buildSafeFilterFormula } from '../utils/airtableHelpers';
import { extractPdfData } from '../utils/peppolAnalyzer/extractPdf';
import { extractExcelData } from '../utils/peppolAnalyzer/extractExcel';
import { validatePeppolRules } from '../utils/peppolAnalyzer/validate';
import { calculateConformityScore } from '../utils/peppolAnalyzer/score';
import { generatePeppolUBL } from '../utils/peppolAnalyzer/generateUbl';

/**
 * Register an uploaded invoice in Airtable
 * POST /api/invoices
 */
export const registerUploadedInvoice = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;
    const { fileName, fileUrl, status, conformityScore, errorsList, errorsData, xmlFilename, ublFileUrl } = req.body;

    // Validate required fields
    if (!fileName || !fileUrl) {
      return res.status(400).json({ error: 'fileName and fileUrl are required' });
    }

    // Validate status
    const validStatuses = ['uploaded', 'checked', 'converted', 'sent'];
    if (status && !validStatuses.includes(status)) {
      return res.status(400).json({ 
        error: `Invalid status "${status}". Must be one of: uploaded, checked, converted, sent` 
      });
    }

    // Check user quota before creating invoice
    const user = await base(TABLES.USERS).find(userId);
    const quotaLimit = user.fields.quotaLimit !== undefined ? Number(user.fields.quotaLimit) : 1;
    const quotaUsed = user.fields.quotaUsed !== undefined ? Number(user.fields.quotaUsed) : 0;
    const isUnlimited = quotaLimit === -1;

    // Block if quota exceeded
    if (!isUnlimited && quotaUsed >= quotaLimit) {
      return res.status(403).json({ 
        error: `Quota limit reached. You have used ${quotaUsed}/${quotaLimit} uploads this month. Upgrade your plan to continue.` 
      });
    }

    // Create invoice record in Airtable
    // Try to save with all fields, fallback gracefully if some fields don't exist
    let records;
    try {
      records = await base(TABLES.INVOICES).create([
        {
          fields: {
            'User': [userId], // Link to Users table
            'File Name': fileName,
            'File URL': fileUrl,
            'Status': status || 'uploaded',
            'Conformity Score': conformityScore || 0,
            'Errors List': errorsList || '',
            'Errors Data': errorsData || '', // JSON string for i18n translation
            'XML Filename': xmlFilename || '', // Real XML filename for UBL download
            'UBL File URL': ublFileUrl || '', // Direct URL for UBL download
            // Note: 'Created At' is auto-generated by Airtable if it's a Created Time field
          },
        },
      ]);
    } catch (error: any) {
      // If new fields don't exist in Airtable, retry without them
      if (error.statusCode === 422 || error.message?.includes('INVALID_FIELD_NAME')) {
        console.log('âš ï¸  Some Airtable fields not found, saving in compatibility mode');
        records = await base(TABLES.INVOICES).create([
          {
            fields: {
              'User': [userId],
              'File Name': fileName,
              'File URL': fileUrl,
              'Status': status || 'uploaded',
              'Conformity Score': conformityScore || 0,
              'Errors List': errorsList || '',
              // New fields omitted - may not exist yet
            },
          },
        ]);
      } else {
        // Re-throw if it's a different error
        throw error;
      }
    }

    const invoice = records[0];

    // Increment quotaUsed after successful upload (only if not unlimited)
    if (!isUnlimited) {
      await base(TABLES.USERS).update(userId, {
        quotaUsed: quotaUsed + 1
      });
    }

    res.status(201).json({
      id: invoice.id,
      fileName: invoice.fields['File Name'],
      fileUrl: invoice.fields['File URL'],
      status: invoice.fields['Status'],
      conformityScore: invoice.fields['Conformity Score'],
      errorsList: invoice.fields['Errors List'],
      errorsData: invoice.fields['Errors Data'],
      xmlFilename: invoice.fields['XML Filename'],
      ublFileUrl: invoice.fields['UBL File URL'],
      createdAt: invoice.fields['Created At'],
    });
  } catch (error: any) {
    console.error('Register invoice error:', error);
    res.status(500).json({ error: 'Failed to register invoice' });
  }
};

/**
 * Get all invoices for the authenticated user
 * GET /api/invoices
 */
export const getInvoices = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;

    // Get all invoices and filter in code
    // Note: Airtable's linked record fields return arrays, so we can't use simple equality
    const records = await base(TABLES.INVOICES)
      .select({
        sort: [{ field: 'Created At', direction: 'desc' }],
      })
      .all();
    
    // Filter records where the User array includes the current userId
    const userRecords = records.filter(record => {
      const userIds = record.fields['User'] as string[] | undefined;
      return userIds && userIds.includes(userId);
    });

    const invoices = userRecords.map((record) => ({
      id: record.id,
      fileName: record.fields['File Name'],
      fileUrl: record.fields['File URL'],
      status: record.fields['Status'],
      conformityScore: record.fields['Conformity Score'],
      errorsList: record.fields['Errors List'],
      errorsData: record.fields['Errors Data'],
      xmlFilename: record.fields['XML Filename'],
      ublFileUrl: record.fields['UBL File URL'],
      createdAt: record.fields['Created At'],
    }));

    res.json({ invoices, count: invoices.length });
  } catch (error) {
    console.error('Get invoices error:', error);
    res.status(500).json({ error: 'Failed to fetch invoices' });
  }
};

/**
 * Analyze an uploaded invoice with Peppol engine
 * POST /api/invoices/analyze
 */
export const analyzeInvoice = async (req: AuthRequest, res: Response) => {
  console.log('ðŸ”µ [ANALYZE] Fonction analyzeInvoice appelÃ©e');
  console.log('ðŸ”µ [ANALYZE] req.file:', req.file ? req.file.filename : 'UNDEFINED');
  console.log('ðŸ”µ [ANALYZE] req.body:', JSON.stringify(req.body));
  
  try {
    if (!req.file) {
      console.error('ðŸ”´ [ANALYZE] Pas de fichier uploadÃ©!');
      return res.status(400).json({ error: 'No file uploaded' });
    }

    const filePath = req.file.path;
    const fileType = req.file.mimetype;
    console.log('ðŸ”µ [ANALYZE] filePath:', filePath);
    console.log('ðŸ”µ [ANALYZE] fileType:', fileType);
    
    // 1. Extraction selon type
    let invoiceData;
    console.log('ðŸ”µ [ANALYZE] Ã‰tape 1: Extraction...');
    if (fileType === 'application/pdf') {
      invoiceData = await extractPdfData(filePath);
    } else if (fileType.includes('spreadsheet') || fileType.includes('excel')) {
      invoiceData = extractExcelData(filePath);
    } else {
      console.error('ðŸ”´ [ANALYZE] Type de fichier non supportÃ©:', fileType);
      return res.status(400).json({ error: 'Type de fichier non supportÃ©. Utilisez PDF ou Excel.' });
    }
    console.log('ðŸ”µ [ANALYZE] DonnÃ©es extraites:', JSON.stringify(invoiceData).substring(0, 200));
    
    // 2. Validation
    console.log('ðŸ”µ [ANALYZE] Ã‰tape 2: Validation...');
    const validationResults = validatePeppolRules(invoiceData);
    console.log('ðŸ”µ [ANALYZE] RÃ©sultats validation:', validationResults.length, 'rÃ¨gles');
    
    // 3. Score
    console.log('ðŸ”µ [ANALYZE] Ã‰tape 3: Calcul du score...');
    const score = calculateConformityScore(validationResults);
    console.log('ðŸ”µ [ANALYZE] Score:', score);
    
    // 4. GÃ©nÃ©ration UBL
    console.log('ðŸ”µ [ANALYZE] Ã‰tape 4: GÃ©nÃ©ration UBL...');
    let ublXml = '';
    let xmlFilename = '';
    
    try {
      console.log('ðŸ”µ [ANALYZE] Appel generatePeppolUBL...');
      ublXml = generatePeppolUBL(invoiceData);
      console.log('ðŸ”µ [ANALYZE] XML gÃ©nÃ©rÃ©, longueur:', ublXml.length, 'caractÃ¨res');
      
      // Calculer le nom XML SANS double extension (.pdf.xml â†’ .xml)
      const originalFilename = req.file.filename;
      const extname = path.extname(originalFilename); // ".pdf" ou ".xlsx"
      const baseFilename = originalFilename.replace(extname, ''); // "invoice-123456789"
      xmlFilename = `${baseFilename}.xml`; // "invoice-123456789.xml"
      console.log('ðŸ”µ [ANALYZE] xmlFilename calculÃ©:', xmlFilename);
      
      // âš ï¸ IMPORTANT: Sur Render (plan gratuit), le filesystem est Ã©phÃ©mÃ¨re!
      // On stocke le contenu XML directement dans Airtable au lieu du disque
      
      // Mise Ã  jour Airtable avec le contenu UBL complet
      const { invoiceId } = req.body;
      console.log('ðŸ”µ [ANALYZE] invoiceId pour update Airtable:', invoiceId);
      
      if (invoiceId) {
        // â­ Ã‰TAPE 1: Sauvegarder le UBL Content EN PREMIER (prioritÃ© absolue)
        console.log('ðŸ”µ [ANALYZE] Ã‰tape 4a: Sauvegarde UBL Content dans Airtable...');
        try {
          await base(TABLES.INVOICES).update(invoiceId, {
            'UBL Content': ublXml,
            'XML Filename': xmlFilename,
            'UBL File URL': `/api/invoices/download-ubl/${invoiceId}`,
          });
          console.log(`âœ… [ANALYZE] UBL Content sauvegardÃ© pour invoice ${invoiceId} (${ublXml.length} caractÃ¨res)`);
        } catch (ublSaveError: any) {
          console.error('ðŸ”´ [ANALYZE] ERREUR sauvegarde UBL Content:', ublSaveError.message);
          console.error('ðŸ”´ [ANALYZE] Code erreur:', ublSaveError.statusCode);
          // Ne pas abandonner - continuer avec les autres champs
        }
        
        // â­ Ã‰TAPE 2: Mettre Ã  jour les autres champs (score, status, etc.)
        console.log('ðŸ”µ [ANALYZE] Ã‰tape 4b: Mise Ã  jour des mÃ©tadonnÃ©es...');
        try {
          await base(TABLES.INVOICES).update(invoiceId, {
            'Conformity Score': score,
            'Status': 'UBL Generated',
          });
          console.log(`âœ… [ANALYZE] Score ${score}% et Status mis Ã  jour pour invoice ${invoiceId}`);
        } catch (metaError: any) {
          console.error('âš ï¸ [ANALYZE] Erreur mise Ã  jour mÃ©tadonnÃ©es:', metaError.message);
        }
        
        // â­ Ã‰TAPE 3: Mettre Ã  jour les champs optionnels (peuvent ne pas exister)
        console.log('ðŸ”µ [ANALYZE] Ã‰tape 4c: Mise Ã  jour des champs optionnels...');
        try {
          await base(TABLES.INVOICES).update(invoiceId, {
            'Invoice Number': invoiceData.invoiceNumber || '',
            'Invoice Date': invoiceData.issueDate || '',
            'Total Amount': invoiceData.totals?.grossAmount || 0,
          });
          console.log(`âœ… [ANALYZE] Champs optionnels mis Ã  jour pour invoice ${invoiceId}`);
        } catch (optionalError: any) {
          // Ces champs sont optionnels, on ignore les erreurs
          console.log('âš ï¸ [ANALYZE] Champs optionnels non mis Ã  jour (normal si non existants)');
        }
        
      } else {
        console.log('âš ï¸ [ANALYZE] Pas de invoiceId fourni, pas de mise Ã  jour Airtable');
      }
    } catch (ublError: any) {
      console.error('ðŸ”´ [ANALYZE] ERREUR dans bloc gÃ©nÃ©ration UBL:', ublError);
      console.error('ðŸ”´ [ANALYZE] Stack trace:', ublError?.stack);
    }
    
    console.log('ðŸ”µ [ANALYZE] Ã‰tape 5: Envoi rÃ©ponse...');
    console.log('ðŸ”µ [ANALYZE] xmlFilename final:', xmlFilename || 'NULL');
    
    // RÃ©cupÃ©rer invoiceId pour la rÃ©ponse
    const responseInvoiceId = req.body.invoiceId;
    
    // 5. RÃ©ponse avec le vrai nom du fichier XML et l'URL basÃ©e sur invoiceId
    res.json({
      success: true,
      score,
      errors: validationResults.filter(v => v.severity === 'error'),
      warnings: validationResults.filter(v => v.severity === 'warning'),
      xmlFilename: xmlFilename || null,
      ublFileUrl: responseInvoiceId ? `/api/invoices/download-ubl/${responseInvoiceId}` : null,
      extractedData: invoiceData
    });
    
  } catch (error: any) {
    console.error('ðŸ”´ [ANALYZE] ERREUR GLOBALE:', error);
    console.error('ðŸ”´ [ANALYZE] Stack:', error?.stack);
    res.status(500).json({ 
      success: false, 
      error: 'Erreur lors de l\'analyse de la facture' 
    });
  }
};

/**
 * Delete an invoice
 * DELETE /api/invoices/:id
 */
export const deleteInvoice = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.userId!;
    const { id } = req.params;

    // First, fetch the record to verify ownership
    const record = await base(TABLES.INVOICES).find(id);

    // Check if the user owns this invoice
    // The 'User' field is an array of user IDs (linked record)
    const userIds = record.fields['User'] as string[];
    if (!userIds || !userIds.includes(userId)) {
      return res.status(403).json({ error: 'Access denied to this invoice' });
    }

    // Delete the invoice
    await base(TABLES.INVOICES).destroy([id]);

    res.json({ message: 'Invoice deleted successfully' });
  } catch (error: any) {
    console.error('Delete invoice error:', error);
    
    if (error.statusCode === 404 || error.message?.includes('NOT_FOUND')) {
      return res.status(404).json({ error: 'Invoice not found' });
    }
    
    res.status(500).json({ error: 'Failed to delete invoice' });
  }
};
